package com.runtimeverification.rvmonitor.java.rvj.output.codedom;

import com.runtimeverification.rvmonitor.java.rvj.output.codedom.analysis.ICodeVisitor;
import com.runtimeverification.rvmonitor.java.rvj.output.codedom.helper.ICodeFormatter;
import com.runtimeverification.rvmonitor.java.rvj.output.codedom.type.CodeType;

/**
 * This class is the root of all expressions. Each expression has a type,
 * represented by a CodeType object.
 *
 * Currently, two different code generation approaches coexist: the old
 * string-concatenation approach and the new CodeDOM approach.
 *
 * @author Choonghwan Lee <clee83@illinois.edu>
 */
public abstract class CodeExpr extends CodeObject {
    protected final CodeType type;

    public CodeType getType() {
        return this.type;
    }

    protected CodeExpr(CodeType type) {
        this.type = type;
    }

    /**
     * Creates an expression from the code generated by the old string-based
     * approach.
     *
     * @see CodeLegacyExpr
     * @param type
     *            type of this expression
     * @param rawexpr
     *            the code generated by the old approach
     * @return expression that encapsulates the given code
     */
    public static CodeExpr fromLegacy(CodeType type, String rawexpr) {
        return new CodeLegacyExpr(type, rawexpr);
    }
}

/**
 * This class represents code generated by the old string-based method and
 * should be considered an expression. Although I replaced the old approach by
 * the new CodeDOM way in many places, the old way is still used. This class
 * encapsulates the string generated by the old method.
 *
 * @author Choonghwan Lee <clee83@illinois.edu>
 */
class CodeLegacyExpr extends CodeExpr {
    private final String rawexpr;

    CodeLegacyExpr(CodeType type, String rawexpr) {
        super(type);

        this.rawexpr = rawexpr;
    }

    @Override
    public void getCode(ICodeFormatter fmt) {
        fmt.legacyExpr(this.rawexpr);
    }

    @Override
    public void accept(ICodeVisitor visitor) {
        // Ideally, one can parse the legacy code and mark referred variables.
        // Given that legacy code should disappear in the future, however, it
        // seems it's waste of time to implement that. The current
        // implementation
        // returns as if the legacy code does not refer to any variable.
    }
}
